

spring:
  redis:
    host: 172.16.2.144
    port: 6379
#  kafka:
#    # 指定kafka server的地址，集群配多个，中间，逗号隔开
#    bootstrap-servers: 172.16.2.155:9092
#    producer: # 生产者
#      retries: 0 # 设置大于0的值，则客户端会将发送失败的记录重新发送
#      # 每次批量发送消息的数量
#      batch-size: 16384
#      buffer-memory: 33554432
#      # 指定消息key和消息体的编解码方式
#      key-serializer: org.apache.kafka.common.serialization.StringSerializer
#      value-serializer: org.apache.kafka.common.serialization.StringSerializer

ftp:
  host: 172.16.2.144
  port: 21
  username: dhx
  password: dhx
  basePath: /
  httPath: ftp://172.16.2.155

time:
  cron: 0 0/5 * * * ?
#ftp:
#  client:
#    connectTimeout: 30000
#    encoding: utf-8
#    host: 172.16.2.155
#    passiveMode: false
#    password: dhx
#    port: 21
#    username: dhx

person:
  lastName: hello
  age: 18
  boss: false
  birth: 2017/12/12
  maps: {k1:v1,k2:12}
  lists:
    - lisi
    - zhaoliu
  dog:
    name: aa
    age: 12

#  kafka:
#    bootstrap-servers: 172.16.2.155:9092
#    producer:
#      # 发生错误后，消息重发的次数。
#      retries: 0
#      #当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。
#      batch-size: 16384
#      # 设置生产者内存缓冲区的大小。
#      buffer-memory: 33554432
#      # 键的序列化方式
#      key-serializer: org.apache.kafka.common.serialization.StringSerializer
#      # 值的序列化方式
#      value-serializer: org.apache.kafka.common.serialization.StringSerializer
#      # acks=0 ： 生产者在成功写入消息之前不会等待任何来自服务器的响应。
#      # acks=1 ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应。
#      # acks=all ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。
#      acks: 0




